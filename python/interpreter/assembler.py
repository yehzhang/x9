import os

from .interpreter import Environmental
from .parser import Nano


class Assembler(Environmental):
    SV_LUT_TEMPLATE = '''\
// parameters used in the LUT
package LUT_def;
    // LUT index
    typedef enum {{
{}
    }} LUT_TYPE;

    // LUT[opcode][imm] => value
    const logic[7:0] kLookupTable[{}][{}] = {};
endpackage
'''
    SV_ARR_TEMPLATE = "'{{{}}}"
    WATERMARK = '// Generated by x9-assembler'
    LUT_CAPACITY = 32
    LUT_MNES = 'lw', 'sw', 'bne', 'beq', 'blts', 'blt'

    def __init__(self, config=None):
        super().__init__(config)
        self.insts = None

    def load(self, filename):
        self.insts = Nano(filename, self.env).parse()
        return self

    def run(self, out_dir):
        """ execute instructions """
        if self.insts is None:
            raise RuntimeError('Assembly file is not loaded')
        if out_dir is None:
            raise RuntimeError('Save directory is not specified')
        out_dir = os.path.abspath(os.path.expanduser(out_dir))
        os.makedirs(out_dir, exist_ok=True)

        # Save machine code
        lines = [(inst.as_code('machine_code'), inst.as_code('asm')) for inst in self.insts]
        mc_width = max(len(mc) for mc, _ in lines)
        text = '\n'.join('{} // {}'.format(mc.ljust(mc_width), asm.splitlines()[0]) for mc, asm in lines)
        self.save(text, out_dir, 'machine_code.txt')

        # Save LUT definitions
        text = self.serialize_luts(self.env)
        self.save(text, out_dir, 'LUT_def.sv')

    @classmethod
    def save(cls, text, dir, filename):
        """ Save generated text to specific location. """
        save_path = os.path.join(dir, filename)
        text = '\n'.join([cls.WATERMARK, text])
        with open(save_path, 'w') as fout:
            fout.write(text)

    @classmethod
    def serialize_luts(cls, env):
        types = []
        luts = []
        luts_default = {m: {} for m in cls.LUT_MNES}
        luts_default.update(env.luts)
        for i, (mne, lut) in enumerate(luts_default.items()):
            types.append((mne, i))
            luts.append((i, lut))

        type_def = ', \n'.join('LUT_{} = {}'.format(m.upper(), i) for m, i in types)

        lut_defs = []
        for i, lut in luts:
            lut = [str(lut.get(i, 0)) for i in range(cls.LUT_CAPACITY)]
            lut = cls.SV_ARR_TEMPLATE.format(', '.join(lut))
            lut_defs.append(lut)
        joined_luts = ', \n'.join(lut_defs)
        tables_def = cls.SV_ARR_TEMPLATE.format('\n{}\n'.format(joined_luts))

        return cls.SV_LUT_TEMPLATE.format(type_def, len(luts), cls.LUT_CAPACITY, tables_def)
